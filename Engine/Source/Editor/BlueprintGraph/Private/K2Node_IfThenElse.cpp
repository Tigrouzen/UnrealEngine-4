// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.


#include "BlueprintGraphPrivatePCH.h"
#include "KismetCompiler.h"

#define LOCTEXT_NAMESPACE "K2Node"

//////////////////////////////////////////////////////////////////////////
// FKCHandler_Branch

class FKCHandler_Branch : public FNodeHandlingFunctor
{
public:
	FKCHandler_Branch(FKismetCompilerContext& InCompilerContext)
		: FNodeHandlingFunctor(InCompilerContext)
	{
	}

	virtual void Compile(FKismetFunctionContext& Context, UEdGraphNode* Node) OVERRIDE
	{
		// For imperative nodes, make sure the exec function was actually triggered and not just included due to an output data dependency
		UEdGraphPin* ExecTriggeringPin = Context.FindRequiredPinByName(Node, CompilerContext.GetSchema()->PN_Execute, EGPD_Input);
		if ((ExecTriggeringPin == NULL) || !Context.ValidatePinType(ExecTriggeringPin, CompilerContext.GetSchema()->PC_Exec))
		{
			CompilerContext.MessageLog.Error(*FString::Printf(*LOCTEXT("NoValidExecutionPinForBranch_Error", "@@ must have a valid execution pin @@").ToString()), Node, ExecTriggeringPin);
			return;
		}
		else if (ExecTriggeringPin->LinkedTo.Num() == 0)
		{
			CompilerContext.MessageLog.Warning(*FString::Printf(*LOCTEXT("NodeNeverExecuted_Warning", "@@ will never be executed").ToString()), Node);
			return;
		}

		// Generate the output impulse from this node
		UEdGraphPin* CondPin = Context.FindRequiredPinByName(Node, CompilerContext.GetSchema()->PN_Condition, EGPD_Input);
		UEdGraphPin* ThenPin = Context.FindRequiredPinByName(Node, CompilerContext.GetSchema()->PN_Then, EGPD_Output);
		UEdGraphPin* ElsePin = Context.FindRequiredPinByName(Node, CompilerContext.GetSchema()->PN_Else, EGPD_Output);
		if (Context.ValidatePinType(ThenPin, CompilerContext.GetSchema()->PC_Exec) &&
			Context.ValidatePinType(ElsePin, CompilerContext.GetSchema()->PC_Exec) &&
			Context.ValidatePinType(CondPin, CompilerContext.GetSchema()->PC_Boolean))
		{
			UEdGraphPin* PinToTry = FEdGraphUtilities::GetNetFromPin(CondPin);
			FBPTerminal** CondTerm = Context.NetMap.Find(PinToTry);

			if (CondTerm != NULL) //
			{
				// First skip the if, if the term is false
				{
					UEdGraphNode* TargetNode = NULL;
					if (ElsePin->LinkedTo.Num() > 0)
					{
						TargetNode = ElsePin->LinkedTo[0]->GetOwningNode();
					}

					FBlueprintCompiledStatement& SkipIfGoto = Context.AppendStatementForNode(Node);
					SkipIfGoto.Type = KCST_GotoIfNot;
					SkipIfGoto.LHS = *CondTerm;
					Context.GotoFixupRequestMap.Add(&SkipIfGoto, TargetNode);
				}

				// Now go to the If branch
				{
					UEdGraphNode* TargetNode = NULL;
					if (ThenPin->LinkedTo.Num() > 0)
					{
						TargetNode = ThenPin->LinkedTo[0]->GetOwningNode();
					}

					FBlueprintCompiledStatement& GotoThen = Context.AppendStatementForNode(Node);
					GotoThen.Type = KCST_UnconditionalGoto;
					GotoThen.LHS = *CondTerm;
					Context.GotoFixupRequestMap.Add(&GotoThen, TargetNode);
				}
			}
			else
			{
				CompilerContext.MessageLog.Error(*LOCTEXT("ResolveTermPassed_Error", "Failed to resolve term passed into @@").ToString(), CondPin);
			}
		}
	}
};

UK2Node_IfThenElse::UK2Node_IfThenElse(const class FPostConstructInitializeProperties& PCIP)
	: Super(PCIP)
{
}

void UK2Node_IfThenElse::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	CreatePin(EGPD_Input, K2Schema->PC_Exec, TEXT(""), NULL, false, false, K2Schema->PN_Execute);
	UEdGraphPin* ConditionPin = CreatePin(EGPD_Input, K2Schema->PC_Boolean, TEXT(""), NULL, false, false, K2Schema->PN_Condition);
	ConditionPin->DefaultValue = ConditionPin->AutogeneratedDefaultValue = TEXT("true");

	UEdGraphPin* TruePin = CreatePin(EGPD_Output, K2Schema->PC_Exec, TEXT(""), NULL, false, false, K2Schema->PN_Then);
	TruePin->PinFriendlyName = FString(*LOCTEXT("true", "true").ToString());

	UEdGraphPin* FalsePin = CreatePin(EGPD_Output, K2Schema->PC_Exec, TEXT(""), NULL, false, false, K2Schema->PN_Else);
	FalsePin->PinFriendlyName = FString(*LOCTEXT("false", "false").ToString());

	Super::AllocateDefaultPins();
}

FString UK2Node_IfThenElse::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return *LOCTEXT("Branch", "Branch").ToString();
}

FLinearColor UK2Node_IfThenElse::GetNodeTitleColor() const
{
	return GEditor->AccessEditorUserSettings().ExecBranchNodeTitleColor;
}

FString UK2Node_IfThenElse::GetTooltip() const
{
	return *LOCTEXT("BrancStatement_Tooltip", "Branch Statement\nIf Condition is true, execution goes to Then, otherwise it goes to Else").ToString();
}

FString UK2Node_IfThenElse::GetKeywords() const
{
	return *LOCTEXT("BranchKeywords", "if").ToString();
}

UEdGraphPin* UK2Node_IfThenElse::GetThenPin() const
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	UEdGraphPin* Pin = FindPin(K2Schema->PN_Then);
	check(Pin != NULL);
	return Pin;
}

UEdGraphPin* UK2Node_IfThenElse::GetElsePin() const
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	UEdGraphPin* Pin = FindPin(K2Schema->PN_Else);
	check(Pin != NULL);
	return Pin;
}

UEdGraphPin* UK2Node_IfThenElse::GetConditionPin() const
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	UEdGraphPin* Pin = FindPin(K2Schema->PN_Condition);
	check(Pin != NULL);
	return Pin;
}

FNodeHandlingFunctor* UK2Node_IfThenElse::CreateNodeHandler(FKismetCompilerContext& CompilerContext) const
{
	return new FKCHandler_Branch(CompilerContext);
}

#undef LOCTEXT_NAMESPACE
